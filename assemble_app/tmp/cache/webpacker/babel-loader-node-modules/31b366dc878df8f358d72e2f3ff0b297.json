{"ast":null,"code":"'use strict';\n\nvar inspect = require('object-inspect');\n\nvar GetIntrinsic = require('../GetIntrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n\nvar Call = require('./Call');\n\nvar Get = require('./Get');\n\nvar GetIterator = require('./GetIterator');\n\nvar IsCallable = require('./IsCallable');\n\nvar IteratorClose = require('./IteratorClose');\n\nvar IteratorStep = require('./IteratorStep');\n\nvar IteratorValue = require('./IteratorValue');\n\nvar Type = require('./Type'); // https://tc39.es/ecma262/#sec-add-entries-from-iterable\n\n\nmodule.exports = function AddEntriesFromIterable(target, iterable, adder) {\n  if (!IsCallable(adder)) {\n    throw new $TypeError('Assertion failed: `adder` is not callable');\n  }\n\n  if (iterable == null) {\n    throw new $TypeError('Assertion failed: `iterable` is present, and not nullish');\n  }\n\n  var iteratorRecord = GetIterator(iterable);\n\n  while (true) {\n    // eslint-disable-line no-constant-condition\n    var next = IteratorStep(iteratorRecord);\n\n    if (!next) {\n      return target;\n    }\n\n    var nextItem = IteratorValue(next);\n\n    if (Type(nextItem) !== 'Object') {\n      var error = new $TypeError('iterator next must return an Object, got ' + inspect(nextItem));\n      return IteratorClose(iteratorRecord, function () {\n        throw error;\n      } // eslint-disable-line no-loop-func\n      );\n    }\n\n    try {\n      var k = Get(nextItem, '0');\n      var v = Get(nextItem, '1');\n      Call(adder, target, [k, v]);\n    } catch (e) {\n      return IteratorClose(iteratorRecord, function () {\n        throw e;\n      });\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}