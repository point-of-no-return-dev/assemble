{"ast":null,"code":"\"use strict\";\n\nvar _object = _interopRequireDefault(require(\"object.assign\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactDom = _interopRequireDefault(require(\"react-dom\"));\n\nvar _server = _interopRequireDefault(require(\"react-dom/server\"));\n\nvar _shallow = _interopRequireDefault(require(\"react-test-renderer/shallow\"));\n\nvar _package = require(\"react-test-renderer/package.json\");\n\nvar _testUtils = _interopRequireDefault(require(\"react-dom/test-utils\"));\n\nvar _semver = _interopRequireDefault(require(\"semver\"));\n\nvar _checkPropTypes2 = _interopRequireDefault(require(\"prop-types/checkPropTypes\"));\n\nvar _has = _interopRequireDefault(require(\"has\"));\n\nvar _reactIs = require(\"react-is\");\n\nvar _enzyme = require(\"enzyme\");\n\nvar _Utils = require(\"enzyme/build/Utils\");\n\nvar _enzymeShallowEqual = _interopRequireDefault(require(\"enzyme-shallow-equal\"));\n\nvar _enzymeAdapterUtils = require(\"enzyme-adapter-utils\");\n\nvar _findCurrentFiberUsingSlowPath = _interopRequireDefault(require(\"./findCurrentFiberUsingSlowPath\"));\n\nvar _detectFiberTags = _interopRequireDefault(require(\"./detectFiberTags\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _createSuper(Derived) {\n  return function () {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (_isNativeReflectConstruct()) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nvar is164 = !!_testUtils[\"default\"].Simulate.touchStart; // 16.4+\n\nvar is165 = !!_testUtils[\"default\"].Simulate.auxClick; // 16.5+\n\nvar is166 = is165 && !_react[\"default\"].unstable_AsyncMode; // 16.6+\n\nvar is168 = is166 && typeof _testUtils[\"default\"].act === 'function';\n\nvar hasShouldComponentUpdateBug = _semver[\"default\"].satisfies(_package.version, '< 16.8'); // Lazily populated if DOM is available.\n\n\nvar FiberTags = null;\n\nfunction nodeAndSiblingsArray(nodeWithSibling) {\n  var array = [];\n  var node = nodeWithSibling;\n\n  while (node != null) {\n    array.push(node);\n    node = node.sibling;\n  }\n\n  return array;\n}\n\nfunction flatten(arr) {\n  var result = [];\n  var stack = [{\n    i: 0,\n    array: arr\n  }];\n\n  while (stack.length) {\n    var n = stack.pop();\n\n    while (n.i < n.array.length) {\n      var el = n.array[n.i];\n      n.i += 1;\n\n      if (Array.isArray(el)) {\n        stack.push(n);\n        stack.push({\n          i: 0,\n          array: el\n        });\n        break;\n      }\n\n      result.push(el);\n    }\n  }\n\n  return result;\n}\n\nfunction nodeTypeFromType(type) {\n  if (type === _reactIs.Portal) {\n    return 'portal';\n  }\n\n  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);\n}\n\nfunction isMemo(type) {\n  return (0, _enzymeAdapterUtils.compareNodeTypeOf)(type, _reactIs.Memo);\n}\n\nfunction isLazy(type) {\n  return (0, _enzymeAdapterUtils.compareNodeTypeOf)(type, _reactIs.Lazy);\n}\n\nfunction unmemoType(type) {\n  return isMemo(type) ? type.type : type;\n}\n\nfunction transformSuspense(renderedEl, prerenderEl, _ref) {\n  var suspenseFallback = _ref.suspenseFallback;\n\n  if (!(0, _reactIs.isSuspense)(renderedEl)) {\n    return renderedEl;\n  }\n\n  var children = renderedEl.props.children;\n\n  if (suspenseFallback) {\n    var fallback = renderedEl.props.fallback;\n    children = replaceLazyWithFallback(children, fallback);\n  }\n\n  if (isStateful(prerenderEl.type)) {\n    var FakeSuspense = /*#__PURE__*/function (_prerenderEl$type) {\n      _inherits(FakeSuspense, _prerenderEl$type);\n\n      var _super = _createSuper(FakeSuspense);\n\n      function FakeSuspense() {\n        _classCallCheck(this, FakeSuspense);\n\n        return _super.apply(this, arguments);\n      }\n\n      _createClass(FakeSuspense, [{\n        key: \"render\",\n        value: function render() {\n          return _react[\"default\"].createElement(prerenderEl.type, _objectSpread({}, prerenderEl.props, {}, this.props), children);\n        }\n      }]);\n\n      return FakeSuspense;\n    }(prerenderEl.type);\n\n    return _react[\"default\"].createElement(FakeSuspense, null, children);\n  }\n\n  return _react[\"default\"].createElement( // eslint-disable-next-line prefer-arrow-callback\n  function FakeSuspense(props) {\n    return _react[\"default\"].createElement(renderedEl.type, _objectSpread({}, renderedEl.props, {}, props), children);\n  }, null, children);\n}\n\nfunction elementToTree(el) {\n  if (!(0, _reactIs.isPortal)(el)) {\n    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);\n  }\n\n  var children = el.children,\n      containerInfo = el.containerInfo;\n  var props = {\n    children: children,\n    containerInfo: containerInfo\n  };\n  return {\n    nodeType: 'portal',\n    type: _reactIs.Portal,\n    props: props,\n    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),\n    ref: el.ref || null,\n    instance: null,\n    rendered: elementToTree(el.children)\n  };\n}\n\nfunction _toTree(vnode) {\n  if (vnode == null) {\n    return null;\n  } // TODO(lmr): I'm not really sure I understand whether or not this is what\n  // i should be doing, or if this is a hack for something i'm doing wrong\n  // somewhere else. Should talk to sebastian about this perhaps\n\n\n  var node = (0, _findCurrentFiberUsingSlowPath[\"default\"])(vnode);\n\n  switch (node.tag) {\n    case FiberTags.HostRoot:\n      return childrenToTree(node.child);\n\n    case FiberTags.HostPortal:\n      {\n        var containerInfo = node.stateNode.containerInfo,\n            children = node.memoizedProps;\n        var props = {\n          containerInfo: containerInfo,\n          children: children\n        };\n        return {\n          nodeType: 'portal',\n          type: _reactIs.Portal,\n          props: props,\n          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: null,\n          rendered: childrenToTree(node.child)\n        };\n      }\n\n    case FiberTags.ClassComponent:\n      return {\n        nodeType: 'class',\n        type: node.type,\n        props: _objectSpread({}, node.memoizedProps),\n        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),\n        ref: node.ref,\n        instance: node.stateNode,\n        rendered: childrenToTree(node.child)\n      };\n\n    case FiberTags.FunctionalComponent:\n      return {\n        nodeType: 'function',\n        type: node.type,\n        props: _objectSpread({}, node.memoizedProps),\n        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),\n        ref: node.ref,\n        instance: null,\n        rendered: childrenToTree(node.child)\n      };\n\n    case FiberTags.MemoClass:\n      return {\n        nodeType: 'class',\n        type: node.elementType.type,\n        props: _objectSpread({}, node.memoizedProps),\n        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),\n        ref: node.ref,\n        instance: node.stateNode,\n        rendered: childrenToTree(node.child.child)\n      };\n\n    case FiberTags.MemoSFC:\n      {\n        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));\n\n        if (renderedNodes.length === 0) {\n          renderedNodes = [node.memoizedProps.children];\n        }\n\n        return {\n          nodeType: 'function',\n          type: node.elementType,\n          props: _objectSpread({}, node.memoizedProps),\n          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: null,\n          rendered: renderedNodes\n        };\n      }\n\n    case FiberTags.HostComponent:\n      {\n        var _renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));\n\n        if (_renderedNodes.length === 0) {\n          _renderedNodes = [node.memoizedProps.children];\n        }\n\n        return {\n          nodeType: 'host',\n          type: node.type,\n          props: _objectSpread({}, node.memoizedProps),\n          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: node.stateNode,\n          rendered: _renderedNodes\n        };\n      }\n\n    case FiberTags.HostText:\n      return node.memoizedProps;\n\n    case FiberTags.Fragment:\n    case FiberTags.Mode:\n    case FiberTags.ContextProvider:\n    case FiberTags.ContextConsumer:\n      return childrenToTree(node.child);\n\n    case FiberTags.Profiler:\n    case FiberTags.ForwardRef:\n      {\n        return {\n          nodeType: 'function',\n          type: node.type,\n          props: _objectSpread({}, node.pendingProps),\n          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: null,\n          rendered: childrenToTree(node.child)\n        };\n      }\n\n    case FiberTags.Suspense:\n      {\n        return {\n          nodeType: 'function',\n          type: _reactIs.Suspense,\n          props: _objectSpread({}, node.memoizedProps),\n          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),\n          ref: node.ref,\n          instance: null,\n          rendered: childrenToTree(node.child)\n        };\n      }\n\n    case FiberTags.Lazy:\n      return childrenToTree(node.child);\n\n    default:\n      throw new Error(\"Enzyme Internal Error: unknown node with tag \".concat(node.tag));\n  }\n}\n\nfunction childrenToTree(node) {\n  if (!node) {\n    return null;\n  }\n\n  var children = nodeAndSiblingsArray(node);\n\n  if (children.length === 0) {\n    return null;\n  }\n\n  if (children.length === 1) {\n    return _toTree(children[0]);\n  }\n\n  return flatten(children.map(_toTree));\n}\n\nfunction _nodeToHostNode(_node) {\n  // NOTE(lmr): node could be a function component\n  // which wont have an instance prop, but we can get the\n  // host node associated with its return value at that point.\n  // Although this breaks down if the return value is an array,\n  // as is possible with React 16.\n  var node = _node;\n\n  while (node && !Array.isArray(node) && node.instance === null) {\n    node = node.rendered;\n  } // if the SFC returned null effectively, there is no host node.\n\n\n  if (!node) {\n    return null;\n  }\n\n  var mapper = function mapper(item) {\n    if (item && item.instance) return _reactDom[\"default\"].findDOMNode(item.instance);\n    return null;\n  };\n\n  if (Array.isArray(node)) {\n    return node.map(mapper);\n  }\n\n  if (Array.isArray(node.rendered) && node.nodeType === 'class') {\n    return node.rendered.map(mapper);\n  }\n\n  return mapper(node);\n}\n\nfunction replaceLazyWithFallback(node, fallback) {\n  if (!node) {\n    return null;\n  }\n\n  if (Array.isArray(node)) {\n    return node.map(function (el) {\n      return replaceLazyWithFallback(el, fallback);\n    });\n  }\n\n  if (isLazy(node.type)) {\n    return fallback;\n  }\n\n  return _objectSpread({}, node, {\n    props: _objectSpread({}, node.props, {\n      children: replaceLazyWithFallback(node.props.children, fallback)\n    })\n  });\n}\n\nvar eventOptions = {\n  animation: true,\n  pointerEvents: is164,\n  auxClick: is165\n};\n\nfunction getEmptyStateValue() {\n  // this handles a bug in React 16.0 - 16.2\n  // see https://github.com/facebook/react/commit/39be83565c65f9c522150e52375167568a2a1459\n  // also see https://github.com/facebook/react/pull/11965\n  // eslint-disable-next-line react/prefer-stateless-function\n  var EmptyState = /*#__PURE__*/function (_React$Component) {\n    _inherits(EmptyState, _React$Component);\n\n    var _super2 = _createSuper(EmptyState);\n\n    function EmptyState() {\n      _classCallCheck(this, EmptyState);\n\n      return _super2.apply(this, arguments);\n    }\n\n    _createClass(EmptyState, [{\n      key: \"render\",\n      value: function render() {\n        return null;\n      }\n    }]);\n\n    return EmptyState;\n  }(_react[\"default\"].Component);\n\n  var testRenderer = new _shallow[\"default\"]();\n  testRenderer.render(_react[\"default\"].createElement(EmptyState));\n  return testRenderer._instance.state;\n}\n\nfunction wrapAct(fn) {\n  if (!is168) {\n    return fn();\n  }\n\n  var returnVal;\n\n  _testUtils[\"default\"].act(function () {\n    returnVal = fn();\n  });\n\n  return returnVal;\n}\n\nfunction getProviderDefaultValue(Provider) {\n  // React stores references to the Provider's defaultValue differently across versions.\n  if ('_defaultValue' in Provider._context) {\n    return Provider._context._defaultValue;\n  }\n\n  if ('_currentValue' in Provider._context) {\n    return Provider._context._currentValue;\n  }\n\n  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');\n}\n\nfunction makeFakeElement(type) {\n  return {\n    $$typeof: _reactIs.Element,\n    type: type\n  };\n}\n\nfunction isStateful(Component) {\n  return Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs) // fallback for createClass components\n  );\n}\n\nvar ReactSixteenAdapter = /*#__PURE__*/function (_EnzymeAdapter) {\n  _inherits(ReactSixteenAdapter, _EnzymeAdapter);\n\n  var _super3 = _createSuper(ReactSixteenAdapter);\n\n  function ReactSixteenAdapter() {\n    var _this;\n\n    _classCallCheck(this, ReactSixteenAdapter);\n\n    _this = _super3.call(this);\n    var lifecycles = _this.options.lifecycles;\n    _this.options = _objectSpread({}, _this.options, {\n      enableComponentDidUpdateOnSetState: true,\n      // TODO: remove, semver-major\n      legacyContextMode: 'parent',\n      lifecycles: _objectSpread({}, lifecycles, {\n        componentDidUpdate: {\n          onSetState: true\n        },\n        getDerivedStateFromProps: {\n          hasShouldComponentUpdateBug: hasShouldComponentUpdateBug\n        },\n        getSnapshotBeforeUpdate: true,\n        setState: {\n          skipsComponentDidUpdateOnNullish: true\n        },\n        getChildContext: {\n          calledByRenderer: false\n        },\n        getDerivedStateFromError: is166\n      })\n    });\n    return _this;\n  }\n\n  _createClass(ReactSixteenAdapter, [{\n    key: \"createMountRenderer\",\n    value: function createMountRenderer(options) {\n      (0, _enzymeAdapterUtils.assertDomAvailable)('mount');\n\n      if ((0, _has[\"default\"])(options, 'suspenseFallback')) {\n        throw new TypeError('`suspenseFallback` is not supported by the `mount` renderer');\n      }\n\n      if (FiberTags === null) {\n        // Requires DOM.\n        FiberTags = (0, _detectFiberTags[\"default\"])();\n      }\n\n      var attachTo = options.attachTo,\n          hydrateIn = options.hydrateIn,\n          wrappingComponentProps = options.wrappingComponentProps;\n      var domNode = hydrateIn || attachTo || global.document.createElement('div');\n      var instance = null;\n      var adapter = this;\n      return _objectSpread({\n        render: function render(el, context, callback) {\n          return wrapAct(function () {\n            if (instance === null) {\n              var type = el.type,\n                  props = el.props,\n                  ref = el.ref;\n\n              var wrapperProps = _objectSpread({\n                Component: type,\n                props: props,\n                wrappingComponentProps: wrappingComponentProps,\n                context: context\n              }, ref && {\n                refProp: ref\n              });\n\n              var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, _objectSpread({}, options, {\n                adapter: adapter\n              }));\n\n              var wrappedEl = _react[\"default\"].createElement(ReactWrapperComponent, wrapperProps);\n\n              instance = hydrateIn ? _reactDom[\"default\"].hydrate(wrappedEl, domNode) : _reactDom[\"default\"].render(wrappedEl, domNode);\n\n              if (typeof callback === 'function') {\n                callback();\n              }\n            } else {\n              instance.setChildProps(el.props, context, callback);\n            }\n          });\n        },\n        unmount: function unmount() {\n          _reactDom[\"default\"].unmountComponentAtNode(domNode);\n\n          instance = null;\n        },\n        getNode: function getNode() {\n          if (!instance) {\n            return null;\n          }\n\n          return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternalFiber), options);\n        },\n        simulateError: function simulateError(nodeHierarchy, rootNode, error) {\n          var isErrorBoundary = function isErrorBoundary(_ref2) {\n            var elInstance = _ref2.instance,\n                type = _ref2.type;\n\n            if (is166 && type && type.getDerivedStateFromError) {\n              return true;\n            }\n\n            return elInstance && elInstance.componentDidCatch;\n          };\n\n          var _ref3 = nodeHierarchy.find(isErrorBoundary) || {},\n              catchingInstance = _ref3.instance,\n              catchingType = _ref3.type;\n\n          (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode, is166 ? catchingType : undefined);\n        },\n        simulateEvent: function simulateEvent(node, event, mock) {\n          var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event, eventOptions);\n          var eventFn = _testUtils[\"default\"].Simulate[mappedEvent];\n\n          if (!eventFn) {\n            throw new TypeError(\"ReactWrapper::simulate() event '\".concat(event, \"' does not exist\"));\n          }\n\n          wrapAct(function () {\n            eventFn(adapter.nodeToHostNode(node), mock);\n          });\n        },\n        batchedUpdates: function batchedUpdates(fn) {\n          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);\n        },\n        getWrappingComponentRenderer: function getWrappingComponentRenderer() {\n          return _objectSpread({}, this, {}, (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({\n            toTree: function toTree(inst) {\n              return _toTree(inst._reactInternalFiber);\n            },\n            getMountWrapperInstance: function getMountWrapperInstance() {\n              return instance;\n            }\n          }));\n        }\n      }, is168 && {\n        wrapInvoke: wrapAct\n      });\n    }\n  }, {\n    key: \"createShallowRenderer\",\n    value: function createShallowRenderer() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var adapter = this;\n      var renderer = new _shallow[\"default\"]();\n      var suspenseFallback = options.suspenseFallback;\n\n      if (typeof suspenseFallback !== 'undefined' && typeof suspenseFallback !== 'boolean') {\n        throw TypeError('`options.suspenseFallback` should be boolean or undefined');\n      }\n\n      var isDOM = false;\n      var cachedNode = null;\n      var lastComponent = null;\n      var wrappedComponent = null;\n      var sentinel = {}; // wrap memo components with a PureComponent, or a class component with sCU\n\n      var wrapPureComponent = function wrapPureComponent(Component, compare) {\n        if (!is166) {\n          throw new RangeError('this function should not be called in React < 16.6. Please report this!');\n        }\n\n        if (lastComponent !== Component) {\n          if (isStateful(Component)) {\n            wrappedComponent = /*#__PURE__*/function (_Component) {\n              _inherits(wrappedComponent, _Component);\n\n              var _super4 = _createSuper(wrappedComponent);\n\n              function wrappedComponent() {\n                _classCallCheck(this, wrappedComponent);\n\n                return _super4.apply(this, arguments);\n              }\n\n              return wrappedComponent;\n            }(Component); // eslint-disable-line react/prefer-stateless-function\n\n\n            if (compare) {\n              wrappedComponent.prototype.shouldComponentUpdate = function (nextProps) {\n                return !compare(_this2.props, nextProps);\n              };\n            } else {\n              wrappedComponent.prototype.isPureReactComponent = true;\n            }\n          } else {\n            var memoized = sentinel;\n            var prevProps;\n\n            wrappedComponent = function wrappedComponent(props) {\n              var shouldUpdate = memoized === sentinel || (compare ? !compare(prevProps, props) : !(0, _enzymeShallowEqual[\"default\"])(prevProps, props));\n\n              if (shouldUpdate) {\n                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                  args[_key - 1] = arguments[_key];\n                }\n\n                memoized = Component.apply(void 0, [_objectSpread({}, Component.defaultProps, {}, props)].concat(args));\n                prevProps = props;\n              }\n\n              return memoized;\n            };\n          }\n\n          (0, _object[\"default\"])(wrappedComponent, Component, {\n            displayName: adapter.displayNameOfNode({\n              type: Component\n            })\n          });\n          lastComponent = Component;\n        }\n\n        return wrappedComponent;\n      }; // Wrap functional components on versions prior to 16.5,\n      // to avoid inadvertently pass a `this` instance to it.\n\n\n      var wrapFunctionalComponent = function wrapFunctionalComponent(Component) {\n        if (is166 && (0, _has[\"default\"])(Component, 'defaultProps')) {\n          if (lastComponent !== Component) {\n            wrappedComponent = (0, _object[\"default\"])( // eslint-disable-next-line new-cap\n            function (props) {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n\n              return Component.apply(void 0, [_objectSpread({}, Component.defaultProps, {}, props)].concat(args));\n            }, Component, {\n              displayName: adapter.displayNameOfNode({\n                type: Component\n              })\n            });\n            lastComponent = Component;\n          }\n\n          return wrappedComponent;\n        }\n\n        if (is165) {\n          return Component;\n        }\n\n        if (lastComponent !== Component) {\n          wrappedComponent = (0, _object[\"default\"])(function () {\n            return Component.apply(void 0, arguments);\n          }, // eslint-disable-line new-cap\n          Component);\n          lastComponent = Component;\n        }\n\n        return wrappedComponent;\n      };\n\n      var renderElement = function renderElement(elConfig) {\n        for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n          rest[_key3 - 1] = arguments[_key3];\n        }\n\n        var renderedEl = renderer.render.apply(renderer, [elConfig].concat(rest));\n        var typeIsExisted = !!(renderedEl && renderedEl.type);\n\n        if (is166 && typeIsExisted) {\n          var clonedEl = transformSuspense(renderedEl, elConfig, {\n            suspenseFallback: suspenseFallback\n          });\n          var elementIsChanged = clonedEl.type !== renderedEl.type;\n\n          if (elementIsChanged) {\n            return renderer.render.apply(renderer, [_objectSpread({}, elConfig, {\n              type: clonedEl.type\n            })].concat(rest));\n          }\n        }\n\n        return renderedEl;\n      };\n\n      return {\n        render: function render(el, unmaskedContext) {\n          var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n              _ref4$providerValues = _ref4.providerValues,\n              providerValues = _ref4$providerValues === void 0 ? new Map() : _ref4$providerValues;\n\n          cachedNode = el;\n          /* eslint consistent-return: 0 */\n\n          if (typeof el.type === 'string') {\n            isDOM = true;\n          } else if ((0, _reactIs.isContextProvider)(el)) {\n            providerValues.set(el.type, el.props.value);\n            var MockProvider = (0, _object[\"default\"])(function (props) {\n              return props.children;\n            }, el.type);\n            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {\n              return renderElement(_objectSpread({}, el, {\n                type: MockProvider\n              }));\n            });\n          } else if ((0, _reactIs.isContextConsumer)(el)) {\n            var Provider = adapter.getProviderFromConsumer(el.type);\n            var value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);\n            var MockConsumer = (0, _object[\"default\"])(function (props) {\n              return props.children(value);\n            }, el.type);\n            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {\n              return renderElement(_objectSpread({}, el, {\n                type: MockConsumer\n              }));\n            });\n          } else {\n            isDOM = false;\n            var renderedEl = el;\n\n            if (isLazy(renderedEl)) {\n              throw TypeError('`React.lazy` is not supported by shallow rendering.');\n            }\n\n            renderedEl = transformSuspense(renderedEl, renderedEl, {\n              suspenseFallback: suspenseFallback\n            });\n            var _renderedEl = renderedEl,\n                Component = _renderedEl.type;\n            var context = (0, _enzymeAdapterUtils.getMaskedContext)(Component.contextTypes, unmaskedContext);\n\n            if (isMemo(el.type)) {\n              var _el$type = el.type,\n                  InnerComp = _el$type.type,\n                  compare = _el$type.compare;\n              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {\n                return renderElement(_objectSpread({}, el, {\n                  type: wrapPureComponent(InnerComp, compare)\n                }), context);\n              });\n            }\n\n            if (!isStateful(Component) && typeof Component === 'function') {\n              return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {\n                return renderElement(_objectSpread({}, renderedEl, {\n                  type: wrapFunctionalComponent(Component)\n                }), context);\n              });\n            }\n\n            if (isStateful) {\n              // fix react bug; see implementation of `getEmptyStateValue`\n              var emptyStateValue = getEmptyStateValue();\n\n              if (emptyStateValue) {\n                Object.defineProperty(Component.prototype, 'state', {\n                  configurable: true,\n                  enumerable: true,\n                  get: function get() {\n                    return null;\n                  },\n                  set: function set(value) {\n                    if (value !== emptyStateValue) {\n                      Object.defineProperty(this, 'state', {\n                        configurable: true,\n                        enumerable: true,\n                        value: value,\n                        writable: true\n                      });\n                    }\n\n                    return true;\n                  }\n                });\n              }\n            }\n\n            return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {\n              return renderElement(renderedEl, context);\n            });\n          }\n        },\n        unmount: function unmount() {\n          renderer.unmount();\n        },\n        getNode: function getNode() {\n          if (isDOM) {\n            return elementToTree(cachedNode);\n          }\n\n          var output = renderer.getRenderOutput();\n          return {\n            nodeType: nodeTypeFromType(cachedNode.type),\n            type: cachedNode.type,\n            props: cachedNode.props,\n            key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),\n            ref: cachedNode.ref,\n            instance: renderer._instance,\n            rendered: Array.isArray(output) ? flatten(output).map(function (el) {\n              return elementToTree(el);\n            }) : elementToTree(output)\n          };\n        },\n        simulateError: function simulateError(nodeHierarchy, rootNode, error) {\n          (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode, is166 ? cachedNode.type : undefined);\n        },\n        simulateEvent: function simulateEvent(node, event) {\n          for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n            args[_key4 - 2] = arguments[_key4];\n          }\n\n          var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event, eventOptions)];\n\n          if (handler) {\n            (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {\n              // TODO(lmr): create/use synthetic events\n              // TODO(lmr): emulate React's event propagation\n              // ReactDOM.unstable_batchedUpdates(() => {\n              handler.apply(void 0, args); // });\n            });\n          }\n        },\n        batchedUpdates: function batchedUpdates(fn) {\n          return fn(); // return ReactDOM.unstable_batchedUpdates(fn);\n        },\n        checkPropTypes: function checkPropTypes(typeSpecs, values, location, hierarchy) {\n          return (0, _checkPropTypes2[\"default\"])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {\n            return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));\n          });\n        }\n      };\n    }\n  }, {\n    key: \"createStringRenderer\",\n    value: function createStringRenderer(options) {\n      if ((0, _has[\"default\"])(options, 'suspenseFallback')) {\n        throw new TypeError('`suspenseFallback` should not be specified in options of string renderer');\n      }\n\n      return {\n        render: function render(el, context) {\n          if (options.context && (el.type.contextTypes || options.childContextTypes)) {\n            var childContextTypes = _objectSpread({}, el.type.contextTypes || {}, {}, options.childContextTypes);\n\n            var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);\n            return _server[\"default\"].renderToStaticMarkup(_react[\"default\"].createElement(ContextWrapper));\n          }\n\n          return _server[\"default\"].renderToStaticMarkup(el);\n        }\n      };\n    } // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation\n    // specific, like `attach` etc. for React, but not part of this interface explicitly.\n    // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: \"createRenderer\",\n    value: function createRenderer(options) {\n      switch (options.mode) {\n        case _enzyme.EnzymeAdapter.MODES.MOUNT:\n          return this.createMountRenderer(options);\n\n        case _enzyme.EnzymeAdapter.MODES.SHALLOW:\n          return this.createShallowRenderer(options);\n\n        case _enzyme.EnzymeAdapter.MODES.STRING:\n          return this.createStringRenderer(options);\n\n        default:\n          throw new Error(\"Enzyme Internal Error: Unrecognized mode: \".concat(options.mode));\n      }\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(element) {\n      return (0, _enzymeAdapterUtils.wrap)(element);\n    } // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed\n    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should\n    // be pretty straightforward for people to implement.\n    // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: \"nodeToElement\",\n    value: function nodeToElement(node) {\n      if (!node || _typeof(node) !== 'object') return null;\n      var type = node.type;\n      return _react[\"default\"].createElement(unmemoType(type), (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));\n    } // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: \"matchesElementType\",\n    value: function matchesElementType(node, matchingType) {\n      if (!node) {\n        return node;\n      }\n\n      var type = node.type;\n      return unmemoType(type) === unmemoType(matchingType);\n    }\n  }, {\n    key: \"elementToNode\",\n    value: function elementToNode(element) {\n      return elementToTree(element);\n    }\n  }, {\n    key: \"nodeToHostNode\",\n    value: function nodeToHostNode(node) {\n      var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var nodes = _nodeToHostNode(node);\n\n      if (Array.isArray(nodes) && !supportsArray) {\n        return nodes[0];\n      }\n\n      return nodes;\n    }\n  }, {\n    key: \"displayNameOfNode\",\n    value: function displayNameOfNode(node) {\n      if (!node) return null;\n      var type = node.type,\n          $$typeof = node.$$typeof;\n      var nodeType = type || $$typeof; // newer node types may be undefined, so only test if the nodeType exists\n\n      if (nodeType) {\n        switch (nodeType) {\n          case (is166 ? _reactIs.ConcurrentMode : _reactIs.AsyncMode) || NaN:\n            return is166 ? 'ConcurrentMode' : 'AsyncMode';\n\n          case _reactIs.Fragment || NaN:\n            return 'Fragment';\n\n          case _reactIs.StrictMode || NaN:\n            return 'StrictMode';\n\n          case _reactIs.Profiler || NaN:\n            return 'Profiler';\n\n          case _reactIs.Portal || NaN:\n            return 'Portal';\n\n          case _reactIs.Suspense || NaN:\n            return 'Suspense';\n\n          default:\n        }\n      }\n\n      var $$typeofType = type && type.$$typeof;\n\n      switch ($$typeofType) {\n        case _reactIs.ContextConsumer || NaN:\n          return 'ContextConsumer';\n\n        case _reactIs.ContextProvider || NaN:\n          return 'ContextProvider';\n\n        case _reactIs.Memo || NaN:\n          {\n            var nodeName = (0, _enzymeAdapterUtils.displayNameOfNode)(node);\n            return typeof nodeName === 'string' ? nodeName : \"Memo(\".concat((0, _enzymeAdapterUtils.displayNameOfNode)(type), \")\");\n          }\n\n        case _reactIs.ForwardRef || NaN:\n          {\n            if (type.displayName) {\n              return type.displayName;\n            }\n\n            var name = (0, _enzymeAdapterUtils.displayNameOfNode)({\n              type: type.render\n            });\n            return name ? \"ForwardRef(\".concat(name, \")\") : 'ForwardRef';\n          }\n\n        case _reactIs.Lazy || NaN:\n          {\n            return 'lazy';\n          }\n\n        default:\n          return (0, _enzymeAdapterUtils.displayNameOfNode)(node);\n      }\n    }\n  }, {\n    key: \"isValidElement\",\n    value: function isValidElement(element) {\n      return (0, _reactIs.isElement)(element);\n    }\n  }, {\n    key: \"isValidElementType\",\n    value: function isValidElementType(object) {\n      return !!object && (0, _reactIs.isValidElementType)(object);\n    }\n  }, {\n    key: \"isFragment\",\n    value: function isFragment(fragment) {\n      return (0, _Utils.typeOfNode)(fragment) === _reactIs.Fragment;\n    }\n  }, {\n    key: \"isCustomComponent\",\n    value: function isCustomComponent(type) {\n      var fakeElement = makeFakeElement(type);\n      return !!type && (typeof type === 'function' || (0, _reactIs.isForwardRef)(fakeElement) || (0, _reactIs.isContextProvider)(fakeElement) || (0, _reactIs.isContextConsumer)(fakeElement) || (0, _reactIs.isSuspense)(fakeElement));\n    }\n  }, {\n    key: \"isContextConsumer\",\n    value: function isContextConsumer(type) {\n      return !!type && (0, _reactIs.isContextConsumer)(makeFakeElement(type));\n    }\n  }, {\n    key: \"isCustomComponentElement\",\n    value: function isCustomComponentElement(inst) {\n      if (!inst || !this.isValidElement(inst)) {\n        return false;\n      }\n\n      return this.isCustomComponent(inst.type);\n    }\n  }, {\n    key: \"getProviderFromConsumer\",\n    value: function getProviderFromConsumer(Consumer) {\n      // React stores references to the Provider on a Consumer differently across versions.\n      if (Consumer) {\n        var Provider;\n\n        if (Consumer._context) {\n          // check this first, to avoid a deprecation warning\n          Provider = Consumer._context.Provider;\n        } else if (Consumer.Provider) {\n          Provider = Consumer.Provider;\n        }\n\n        if (Provider) {\n          return Provider;\n        }\n      }\n\n      throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');\n    }\n  }, {\n    key: \"createElement\",\n    value: function createElement() {\n      return _react[\"default\"].createElement.apply(_react[\"default\"], arguments);\n    }\n  }, {\n    key: \"wrapWithWrappingComponent\",\n    value: function wrapWithWrappingComponent(node, options) {\n      return {\n        RootFinder: _enzymeAdapterUtils.RootFinder,\n        node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react[\"default\"].createElement, node, options)\n      };\n    }\n  }]);\n\n  return ReactSixteenAdapter;\n}(_enzyme.EnzymeAdapter);\n\nmodule.exports = ReactSixteenAdapter; //# sourceMappingURL=ReactSixteenAdapter.js.map","map":null,"metadata":{},"sourceType":"module"}